<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Instance Profile</title>
  <style type="text/css">
    body {
      font-family: 'Helvetica Neue', Helvetica, sans-serif;
      padding: 0.5em 1em;
    }

    table {}

    table.entity {
      width: 100%;
      border-collapse: collapse;
      font-family: 'InputMono', 'Consolas', monospace;
    }

    body>table,
    th,
    td {
      border-width: 1px;
      border-color: #ccc;
      border-style: solid;
    }

    th,
    td {
      padding: 0;
      vertical-align: top;
      text-align: left;
      border-style: none solid solid none;
    }

    table.entity table.entity td:last-child {
      border-right-style: none;
    }

    table.entity table.entity tr:last-child td {
      border-bottom-style: none;
    }

    th,
    td.atomic {
      padding: 0.25em 0.5em;
    }

    thead {}

    thead th {
      font-weight: normal;
    }

    pre {
      font-family: 'InputMono', 'Consolas', monospace;
    }

  </style>
  <script type="text/javascript">
    /**
     * Whether something is iterable, not including `string` instances.
     *
     * @param {*} item
     * @param {boolean} [ignoreStrings = true]
     * @return {boolean}
     */
    function isIterable(item, ignoreStrings = true) {
      if (!exists(item)) return false;
      if ('function' === typeof item[Symbol.iterator]) {
        return 'string' !== typeof item || !ignoreStrings;
      }
      return false;
    }
    /**
     * Whether something is not `undefined` or `null`
     *
     * @param {*} item
     * @return {boolean}
     */
    function exists(item) {
      return !('undefined' === typeof item || null === item);
    }
    /**
     * Whether something doesn’t exist or is *not* an empty `string`
     *
     * @param {*} item
     * @return {boolean}
     */
    function isEmpty(item) {
      return !exists(item) || '' === item;
    }
    /**
     * Guarantees an interable, even if passed a non-iterable,
     * except for `undefined` and `null`, which are returned as-is.
     *
     * @param {*} oneOrMany
     * @return {Iterable|Array|null|undefined}
     */
    function toIterable(oneOrMany) {
      if (!exists(oneOrMany)) return oneOrMany;
      if (isIterable(oneOrMany)) return oneOrMany;
      return [oneOrMany];
    }

    /**
     * Creates a `Node` instance.
     *
     * @param {Node|string|null|undefined} name
     * @return {Node}
     */
    function createElement(name) {
      if (name instanceof Node) return name;
      if (isEmpty(name)) return document.createDocumentFragment();
      return document.createElement(String(name));
    }

    /**
     *
     * @param {Iterable|Node|string|Object} param
     * @param {Node} el
     * @return {Node}
     */
    function applyToElement(param, el) {
      if (isIterable(param)) {
        for (const item of param) {
          applyToElement(item, el);
        }
        return el;
      }

      if (param instanceof Node) {
        el.appendChild(param);
        return el;
      }

      if ('string' === typeof param) {
        el.appendChild(document.createTextNode(param));
        return el;
      }

      if (exists(param) && 'object' === typeof param) {
        for (const p of [
          ...Object.getOwnPropertyNames(param),
          ...Object.getOwnPropertySymbols(param),
        ]) {
          switch (p) {
            case 'style':
            case 'dataset':
              for (let item in param[p]) {
                if (exists(item)) el[p][item] = param[p][item];
              }
              break;
            case 'class':
            case 'className':
            case 'classList':
              for (const cls of toIterable(param[p])) {
                if (exists(cls)) el.classList.add(cls);
              }
              break;
            default:
              el[p] = param[p];
          }
        }
      }
      return el;
    }

    /**
     *
     * @param {string|Node|undefined|null} name
     * @param {Iterable} rest
     * @return {Node}
     */
    function element(name, ...rest) {
      const el = createElement(name);
      for (const param of rest) {
        applyToElement(param, el);
      }
      return el;
    }

    const toFragment = (...rest) => element(null, ...rest);
    const empty = () => toFragment();

    const header = (...rest) => element('header', ...rest);
    const nav = (...rest) => element('nav', ...rest);
    const footer = (...rest) => element('footer', ...rest);
    const div = (...rest) => element('div', ...rest);
    const p = (...rest) => element('p', ...rest);
    const h1 = (...rest) => element('h1', ...rest);
    const h2 = (...rest) => element('h2', ...rest);
    const h3 = (...rest) => element('h3', ...rest);
    const h4 = (...rest) => element('h4', ...rest);
    const h5 = (...rest) => element('h5', ...rest);
    const h6 = (...rest) => element('h6', ...rest);

    const ul = (...rest) => element('ul', ...rest);
    const ol = (...rest) => element('ol', ...rest);
    const li = (...rest) => element('li', ...rest);
    const dl = (...rest) => element('dl', ...rest);
    const dt = (...rest) => element('dt', ...rest);
    const dd = (...rest) => element('dd', ...rest);

    const table = (...rest) => element('table', ...rest);
    const thead = (...rest) => element('thead', ...rest);
    const tfoot = (...rest) => element('tfoot', ...rest);
    const tbody = (...rest) => element('tbody', ...rest);
    const tr = (...rest) => element('tr', ...rest);
    const th = (...rest) => element('th', ...rest);
    const td = (...rest) => element('td', ...rest);

    const span = (...rest) => element('span', ...rest);
    const a = (...rest) => element('a', ...rest);
    const em = (...rest) => element('em', ...rest);
    const strong = (...rest) => element('strong', ...rest);
    const mark = (...rest) => element('mark', ...rest);

    const input = (...rest) => element('input', { type: 'text' }, ...rest);
    const button = (...rest) => element('button', ...rest);
    const text = input;
    const textarea = (...rest) => element('textarea', ...rest);
    const checkbox = (...rest) =>
      element('input', { type: 'checkbox' }, ...rest);
    const radio = (...rest) => element('input', { type: 'radio' }, ...rest);
    const select = (...rest) => element('select', ...rest);
    const option = (...rest) => element('option', ...rest);
    const file = (...rest) => element('input', { type: 'file' }, ...rest);

    const br = (...rest) => element('br', ...rest);
    const hr = (...rest) => element('hr', ...rest);

    /**
     * Replaces the entire contents of `oldNode` with `newChild`.
     * It’s generally advisable to use a `DocumentFragment` for the
     * the replacement.
     *
     * @param {Node} oldNode
     * @param {Node|DocumentFragment|NodeList|Array<Node>} newChild
     * @returns {Node}  - The new parent wrapper
     */
    function replaceChildren(oldNode, newChild) {
      if (!oldNode) return;
      const tmpParent = oldNode.cloneNode();
      if (newChild) {
        if (newChild instanceof Node) {
          tmpParent.appendChild(newChild);
        } else {
          Array.prototype.forEach.call(newChild, child =>
            tmpParent.appendChild(child)
          );
        }
      }
      oldNode.parentNode.replaceChild(tmpParent, oldNode);
      return tmpParent;
    }

    const store = {};

    function renderCustomers(customers) {
      return customers.map((customer, index) => tr(
        td({ dataset: { parent: 'customer.id' }, className: 'atomic' }, customer.id),
        td({ dataset: { parent: 'customer.name.first' }, className: 'atomic' }, customer.name.first),
        td({ dataset: { parent: 'customer.name.last' }, className: 'atomic', className: 'atomic' }, customer.name.last),
        td({ dataset: { parent: 'customer.address.street' } }, customer.address.street),
        td({ dataset: { parent: 'customer.address.city' }, className: 'atomic' }, customer.address.city),
        td({ dataset: { parent: 'customer.address.zip' }, className: 'atomic' }, customer.address.zip),
        td({ dataset: { parent: 'customer.notes' } }, renderNotes(customer.notes)),
        td({ dataset: { parent: 'customer.verified' }, className: 'atomic' }, String(customer.verified))));
    }

    function renderNotes(notes) {
      return table(
        tbody(notes.map(note => tr(td(note.timestamp, { className: 'atomic' }), td(note.text, { className: 'atomic' })))),
        { className: 'entity', }
      )
    }

    document.addEventListener('DOMContentLoaded', (evt) => {
      fetch('customers.json')
        .then(response => {
          if (200 === response.status) {
            return response.json()
          } else {
            throw new Error('Did you generate the fake customers with npm run generate?');
          }
        }
        )
        .then(customers => replaceChildren(document.querySelector('tbody'),
          renderCustomers(customers))
        ).catch(error => console.error(error));
      document.querySelector('table').addEventListener('click', evt => console.log(evt.target));
    });
  </script>
</head>

<body>
  <h1>Customer</h1>
  <p class="description">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris ac quam tempus, finibus velit sed, lacinia leo. Morbi id commodo risus, sed fermentum tellus. Nam sit amet condimentum nisi. Nullam et sem et lorem pulvinar blandit. Quisque et sodales odio. Quisque non pretium diam, quis interdum libero. Integer tortor nisl, elementum in molestie et, ultricies vitae libero. </p>
  <ul>
    <li>Mixed content</li>
    <li>Data types</li>
    <li>Arrays and multiplicity: Can we assume that the order of children doesn’t matter, as with JSON?</li>
  </ul>
  <table class="entity xml">
    <thead>
      <tr data-level="0">
        <th colspan="8">customer</th>
      </tr>
      <tr data-level="1">
        <th colspan="1" rowspan="2" id="customer.@id" data-parent="customer">@id</th>
        <th colspan="2" id="customer.name" data-parent="customer">name</th>
        <th colspan="3" id="customer.address" data-parent="customer">address</th>
        <th colspan="1" rowspan="2" id="customer.notes" data-parent="customer">notes</th>
        <th colspan="1" rowspan="2" id="customer.verified" data-parent="customer">verified</th>
      </tr>
      <tr data-level="2">
        <th id="customer.name.first" data-parent="customer.name">first</th>
        <th id="customer.name.family" data-parent="customer.name">family</th>
        <th id="customer.name.street" data-parent="customer.address">street</th>
        <th id="customer.address.city" data-parent="customer.address">city</th>
        <th id="customer.address.zip" data-parent="customer.address">zip</th>
      </tr>
    </thead>
    <tbody>
      <!--
      <tr>
        <td data-parent="customer.name.@id">148b434b-f4fc-4d91-896f-9e72c0a2d83e</td>
        <td data-parent="customer.name.first">Sam</td>
        <td data-parent="customer.name.family">McDaniel</td>
        <td data-parent="customer.address.city">Pittsburgh</td>
        <td data-parent="customer.address.street">33 Main Street</td>
        <td data-parent="customer.address.zip">15204</td>
        <td data-parent="customer.address.verified">true</td>
      </tr>
      -->
    </tbody>
  </table>
  <pre>
&lt;customer id="148b434b-f4fc-4d91-896f-9e72c0a2d83e"&gt;
  &lt;name&gt;
    &lt;first&gt;Sam&lt;/first&gt;
    &lt;family&gt;McDaniel&lt;/family&gt;
  &lt;/name&gt;
  &lt;address&gt;
    &lt;street&gt;33 Main Street&lt;/street&gt;
    &lt;city&gt;Pittsburgh&lt;/city&gt;
    &lt;zip&gt;15204&lt;/zip&gt;
  &lt;/address&gt;
  &lt;verified&gt;true&lt;/verified&gt;
&lt;/customer&gt;
  </pre>
</body>

</html>
