<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Table</title>
  <link rel="stylesheet" type="text/css" href="" />
  <script type="application/javascript" src=""></script>
  <style type="text/css">
    body {
      padding: 0.5em 1em;
      font-family: 'Helvetica Neue', 'Helvetica', sans-serif;
      font-size: 10pt;
    }

    pre {
      font-family: 'InputMono', 'Consolas', monospace;
    }

  </style>
  <style type="text/css">
    table {
      width: 100%;
      font-family: 'InputMono', 'Consolas', monospace;
      border-collapse: collapse;
      margin: 0;
    }

    tbody tr:first-child td {
      border-top: solid 1px #333;
    }

    tbody:nth-child(2n+1) {
      background: #f1f1f1;
    }

    tbody:hover td {
      background: palegoldenrod;
    }

    th,
    td {
      border: solid 0.5px #999;
      padding: 0.5em 0.5em;
      vertical-align: top;
      text-align: left;
    }

    td.undefined {
      background: repeating-linear-gradient( 45deg,
      #606dbc,
      #606dbc 10px,
      #465298 10px,
      #465298 20px);
    }

  </style>
  <script type="text/javascript" src="util.js"></script>
  <script type="text/javascript">
    const doc = {
      a: "AA", /* 1 */
      b: "BBB", /* 1 */
      c: [
        "C0" /* 1 */, "C1", /* 2 */ "C2" /* 3 */
      ],
      d: [
        { e: "E0", f: "F0" }, /* 1 */
        { e: "E1", f: "F1" }, /* 2 */
        { e: "E2", f: "F2", k: [1, 2, 3] }, /* 3, 4, 5 */
        { e: "E3", f: "F3" }  /* 4 */
      ],
      g: { h: { i: "I", j: "J" } } /* 1 */
    };

    // ["A","B",[["C0"],["C1"],["C2"]],[["E0","F0"],["E1","F1"],["E2","F2",[[1],[2],[3]]],["E3","F3"]],"I","J"]

    /*
    ["A", "B", [["C0"], 
                ["C1"], 
                ["C2"]], [["E0", "F0"], 
                          ["E1", "F1"], 
                          ["E2", "F2"], 
                          ["E3", "F3"]], "I", "J"]
    */

    function* all(itr) {
      for (const item of itr) {
        yield* traverse(item);
      }
    }
    function* propertyValues(obj) {
      for (const prop of Object.getOwnPropertyNames(obj)) {
        yield obj[prop];
      }
    }

    function* traverse(obj) {
      /*
      if (isPrimitiveOrNull(obj)) {
        return accumulator.push(obj);
      } else if (Array.isArray(obj)) {
        const coll = [];
        accumulator.push(obj.map(item => traverse(item, coll)));
      } else {
        for (const prop of Object.getOwnPropertyNames(obj)) {
          const item = obj[prop];
          traverse(item, accumulator);
        }
      }
      return accumulator;
      */
      if (isPrimitiveOrNull(obj)) {
        yield obj;
      } else if (Array.isArray(obj)) {
        yield Array.from(all(obj));
      } else {
        // Need to be able to differentiate between a set of property values
        // and an array of items
        yield new Set(all(propertyValues(obj)));
      }
    }





    function startsWith(arr, seg) {
      if (!Array.isArray(arr) || !Array.isArray(seg)) return false;
      if (arr.length < seg.length) return false;
      for (let i = 0; i < seg.length; i++) {
        if (arr[i] !== seg[i]) return false;
      }
      return true;
    }

    function tablify(itr) {
      let cols = [];
      for (const item of itr) {
        if (item instanceof Set) {
          console.log('Set item', String(item));
          cols = [...cols, 'string' === typeof item ? item : tablify(item)];
        } else if (Array.isArray(item)) {
          console.log('Array item', item.length, String(item[0]));
          cols.push('string' === typeof item[0] ? item[0] : tablify(item[0]));
          console.log('REST', item.slice(1));
        } else {
          console.log('Primitive', item);
          cols.push(item);
        }
      }
      return cols;
    }

    function flatten(array) {
      return Array.isArray(array) ? [].concat.apply([], array.map(flatten)) : array;
    }

    function tablify1(flat) {
      let depth = 0;
      const rows = [];
      let counter = 0;
      let current = flat;
      let rest = [];
      do {
        rows[depth] = [];
        let col = 0;
        for (let c = 0; c < current.length; c++) {
          const item = current[c];
          if (Array.isArray(item)) {
            const newItems = item.shift();
            if (item.length > 0) {
              rows[depth] = rows[depth].concat(newItems);
              rest.push(item);
              col += newItems.length;
            }
          } else {
            rows[depth][col] = item;
            col++;
          }
        }
        console.log(JSON.stringify(rows[depth]));
        console.log(JSON.stringify(rest));
        console.log("----------------------");
        current = rest;
        depth++;
      } while (rest.length > 0 && counter++ < 10);
      return rows;
    }

    function tablify2(flat) {
      const rows = [], rest = [];
      let current = flat;
      let depth = -1;

      do {
        depth++;
        let index = 0;
        rows[depth] = [];
        for (let c = 0; c < current.length; c++) {
          let item = current[c];
          if (Array.isArray(item)) {
            const first = item.shift();
            let j = 0;
            for (; j < first.length; j++) {
              if (Array.isArray(first[j])) {
                const second = first[j].shift();
                if (second.length > 0) {
                  rest.push(second);
                }
              } else {
                rows[depth].push(first[j]);
              }
            }
            if (item.length > 0) {
              rest.push(item);
            } else {
              item = undefined;
            }
            index += j;
          } else {
            rows[depth][index] = item;
            index++;
          }
        }
        current = Array.from(rest);
      } while (rest.length > 0)
      return rows;
    }
    // console.log(JSON.stringify(doc, null, 2));
    // console.log(JSON.stringify(...traverse(doc)));
    // console.log(...traverse(doc));
    // console.log('tablify');
    // console.log(tablify(traverse(doc)));

    /*
    class Path extends Array {
      clone(extras = []) {
        return new Path(...this, ...extras);
      }
      [Symbol.toPrimitive](hint) {
        return this.join('.');
      }
    }
    console.assert(new Path('a', 'b', 'c').length === 3);
    console.assert(String(new Path('a', 'b', 'c')) === 'a.b.c');
    */

    class PathMap extends Map {
      bySegement(segment) {
        if (!Array.isArray(segment)) throw new TypeError();
        const map = new PathMap();
        for (const entry of this.entries()) {
          if (startsWith(entry[0], segment)) {
            map.set(entry[0], entry[1]);
          }
        }
        return map;
      }
      reduceArrays() {
        const map = new PathMap();
        for (const entry of this.entries()) {
          const path = entry[0].filter(segment => 'number' !== typeof segment);
          map.set(path, 'stuff');
        }
        return map;
      }
      get [Symbol.toStringTag]() {
        return '\n' + Array.from(this.entries())
          .map(entry => `${entry[0].join('.')}: ${entry[1]}`)
          .join('\n');
      }
    }
    function paths(obj) {
      function visit(o, f, parents = []) {
        if (isPrimitiveOrNull(o)) {
          f([...parents], o);
        } else if (Array.isArray(o)) {
          let index = 0;
          for (const item of o) {
            visit(item, f, [...parents, index++]);
          }
        } else {
          for (const p of Object.getOwnPropertyNames(o)) {
            visit(o[p], f, [...parents, p]);
          }
        }
      }
      const out = new PathMap();
      visit(obj, (paths, value) => out.set(paths, { value }));
      return out;
    }

    const p = paths(doc);
    console.log(p);

    function isPrimitiveOrNull(value) {
      if (null === value) return true;
      switch (typeof value) {
        case 'undefined':
        case 'string':
        case 'number':
        case 'boolean':
        case 'symbol':
        case 'function':
          return true;
        case 'object':
          return value instanceof Date;
      }
      return false;
    }
    function isNullOrUndefined(value) {
      return 'undefined' === typeof value || null === value;
    }
    function isObject(value) {
      return !isPrimitiveOrNull(value) && 'object' === typeof value;
    }
    function isIterable(obj, ignoreStrings = true) {
      if (isNullOrUndefined(obj)) return false;
      if ('string' === typeof obj) return !ignoreStrings;
      return Boolean(obj[Symbol.iterator]);
    };
    document.addEventListener('DOMContentLoaded', evt => {
      const table = document.querySelector('#dyn');

    });
  </script>
</head>

<body>
  <h2>Input Documents</h2>
  <p>The outer array holds a collection of entity instances. We can intially assume that the instances share a common structure. </p>
  <pre>
    [
      {
        a: "A",
        b: "B",
        c: [
          "C0", "C1", "C2"
        ],
        d: [
          { e: "E0", f: "F0" },
          { e: "E1", f: "F1" },
          { e: "E2", f: "F2", k: [1, 2, 3] },
          { e: "E3", f: "F3" }
        ],
        g: { h: { i: "I", j: "J" } }
      };,â€¦
    ]
      </pre>
  <h2>Output Table</h2>
  <table id="static">
    <thead>
      <tr>
        <th rowspan="4">a</th>
        <th rowspan="4">b</th>
        <th rowspan="4">c</th>
        <th colspan="3">d</th>
        <th colspan="2">g</th>
      </tr>
      <tr>
        <th rowspan="3">e</th>
        <th rowspan="3">f</th>
        <th rowspan="3">k</th>
      </tr>
      <tr>
        <th colspan="2">h</th>
      </tr>
      <tr>
        <th>i</th>
        <th>j</th>
      </tr>
    </thead>
    <tbody data-rownum="1">
      <tr>
        <td rowspan="7">A</td>
        <td rowspan="7">B</td>
        <td>C0</td>
        <td>E0</td>
        <td>F0</td>
        <td class="undefined"></td>
        <td rowspan="6">I</td>
        <td rowspan="6">J</td>
      </tr>
      <tr>
        <td>C1</td>
        <td>E1</td>
        <td>F1</td>
        <td class="undefined"></td>
      </tr>
      <tr>
        <td>C2</td>
        <td rowspan="3">E2</td>
        <td rowspan="3">F2</td>
        <td>1</td>
      </tr>
      <tr>
        <td class="undefined" rowspan="3"></td>
          <!-- leftovers from c.length > d.length -->
        </td>
        <td>2</td>
      </tr>
      <tr>
        <td>3</td>
      </tr>
      <tr>
        <td>E3</td>
        <td>F3</td>
        <td class="undefined"></td>
      </tr>
    </tbody>
  </table>
  <table id="dyn"></table>
</body>

</html>
